

%option noyywrap
%x MODE_ML_COMMENT
%x MODE_SL_COMMENT
%x MODE_STRING
%x MODE_CHARSEQ

%{

  //####################

#include <iostream>
#include <string>
#include <cassert>

#define YY_NO_UNISTD_H

#include "token_id.hpp"

#include "src_lexer.hpp"
#include <quan/atomicstring.hpp>
#include <quan/gc.hpp>

#define YY_DECL int quan_lexer::src_lexer::yylex(token_type & tok)

#define yyterminate() \
   tok.m_position = m_position;\
   return tok.m_token_id = quan_lexer::token::eof;

#undef yywrap
#define yywrap() 1

#undef yyFlexLexer

using std::cin;
using std::cout;
using std::cerr;

   //#############################
   // derive own class from
   // yyFlexLexer
   // the yyFlexLexer must be defined
   // for linkage purposes

int yyFlexLexer::yylex(){assert(false); return 0;}

%} /*############################## */

 /* scanner */

BLANK             [ \t]
ALPHA             [A-Za-z]
DIGIT             [0-9]
HEXDIGIT          [0-9A-Fa-f]
OPERATOR          [!&-+*/=~|<>^?~%#@]
PUNCT             [\(\)\{\}\[\]\:\;\,\.\"]
NOTNL             .
IDCHAR            {ALPHA}|"_"
UNIXNEWL          [\n]
MACNEWL           [\r]
ESCCHAR           [\'\"\\btnvfr]
NEWL              {UNIXNEWL}|({MACNEWL}{UNIXNEWL}?)
NONESCAPECHAR     {ALPHA}|{DIGIT}|{OPERATOR}|{PUNCT}|"_"
HEXESCAPE         "\\x\("{HEXDIGIT}+"\)"
DECESCAPE         "\\d\("{DIGIT}+"\)"
CHARESCAPE        "\\"{ESCCHAR}
 /* any of 256 source characters */
ANY               ({NOTNL}|{NEWL})
 /* normal string/char seq character: any but quote,  or backslash */
STRCHAR           [^\'\"\\\n\b\v\t\f\r]

%%  /*############################### */

  /*----------------------  initial -----------------------*/

<INITIAL>{BLANK}+ {
   m_position.column += yyleng;
}

<INITIAL>{NEWL} {
   m_position.column = 1; ++m_position.row;
}

<INITIAL>"\"" {
   // start string mode
   m_lexeme = "";
   tok.m_position = m_position;
   ++m_position.column;
   BEGIN(MODE_STRING);
}

<INITIAL>"'" {
   // start charseq mode
   m_lexeme = "";
   tok.m_position = m_position;
   ++m_position.column;
   BEGIN(MODE_CHARSEQ);
}

<INITIAL>"/*" {
     // start of multi line comment
      BEGIN(MODE_ML_COMMENT);
}

<INITIAL>"//" {
    // start of single line comment
      BEGIN(MODE_SL_COMMENT);
}

<INITIAL>"state" {
   return do_tokenID(tok,quan_lexer::STATE_);
}

<INITIAL>"jump" {
   return do_tokenID(tok,quan_lexer::JUMP_);
}

<INITIAL>"append" {
   return do_tokenID(tok,quan_lexer::APPEND_);
}

<INITIAL>"emit" {
   return do_tokenID(tok,quan_lexer::EMIT_);
}

<INITIAL>"pushfpos" {
   return do_tokenID(tok,quan_lexer::PUSHFPOS_);
}

<INITIAL>"popfpos" {
   return do_tokenID(tok,quan_lexer::POPFPOS_);
}

<INITIAL>"default" {
   return do_tokenID(tok,quan_lexer::DEFAULT_);
}

<INITIAL>{IDCHAR}({IDCHAR}|{DIGIT})* {
   do_string_handle(tok);
   return tok.m_token_id = quan_lexer::NAME_;
}

<INITIAL>".." {
   return do_tokenID(tok,quan_lexer::DOT_DOT_);
}

<INITIAL>"$"|"."|"="|","|"|"|"&"|";"|"{"|"}"|"?"|"*"|"+"|"("|")"|"!"|"["|"]" {
   return do_tokenID(tok);
}

   /* ------------------- string  ---------------------*/

<MODE_STRING>"\"" {
   ++m_position.column;
   BEGIN(INITIAL);
   return do_string_literal(tok);
}

<MODE_STRING>{NEWL} {
   m_position.column = 1; ++m_position.row;
   BEGIN(INITIAL);
   return do_error(tok,"raw return char in string literal",0);
}

<MODE_STRING>{STRCHAR}+  {
   m_lexeme += yytext;
   m_position.column += yyleng;
}

   /*--------------charseq -----------------------------*/

<MODE_CHARSEQ,MODE_STRING>{HEXESCAPE} {
   m_lexeme += yytext;
   m_position.column += yyleng;
}

<MODE_CHARSEQ,MODE_STRING>{DECESCAPE} {
   m_lexeme += yytext;
   m_position.column += yyleng;
}

<MODE_CHARSEQ,MODE_STRING>{CHARESCAPE} {
   m_lexeme += yytext;
   m_position.column += yyleng;
}

<MODE_CHARSEQ>"'" {
   ++m_position.column;
   BEGIN(INITIAL);
   return do_charseq(tok);
}

<MODE_CHARSEQ,MODE_STRING>"\"" {
   m_lexeme += yytext;
   m_position.column += yyleng;
}

<MODE_CHARSEQ>{NEWL} {
   m_position.column = 1; ++m_position.row;
   BEGIN(INITIAL);
   return do_error(tok,"raw return char in character_set",0);
}

   /*---- common string  and character sequence --- */

<MODE_CHARSEQ,MODE_STRING>"\\"{NOTNL} {
   m_lexeme += yytext;
   //BEGIN(INITIAL);
   return do_error(tok,"unknown escape char",yyleng +1);
}

<MODE_CHARSEQ>{STRCHAR}+ {
   m_lexeme += yytext;
   m_position.column += yyleng;
}

   /*--------------comment (multiline)  -----------------------------*/

<MODE_ML_COMMENT>[^*\n]* {
   /* eat anything that's not a '*'  */
}

<MODE_ML_COMMENT>"*"+[^*/\n]* {
   /* eat '*'s not followed by '/'s */
}

<MODE_ML_COMMENT>"\n"  {
   m_position.column = 1; ++m_position.row;
}

<MODE_ML_COMMENT>"*"+"/"  {
   BEGIN(INITIAL);
}

   /*--------------comment (single line)  -----------------------------*/

<MODE_SL_COMMENT>[^\n]    /* eat up anything except a return */
<MODE_SL_COMMENT>"\n" {
   m_position.column = 1; ++m_position.row;
   BEGIN(INITIAL);
}

   /*anything else */

. {
   init_tok(tok);
   tok.m_token_id = quan_lexer::token::undefined;
   tok.m_lexeme = yytext;
   return tok.m_token_id = yytext[0] ;
}

%%
