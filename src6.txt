
   /*** sample lexer ***/

   state string_literal    ;
   state mlcomment ;
   state slcomment ;
   state main default;
   
   newl = '\n' | "\r\n" ;
 
   /*
       Some characters cannot be represented as text, so they must be represented using escapes.
       
       a '\' character read in a string literal represents the start of an escaped character
       Valid characters following escape are \"'abfnrtv
       To represent arbitrary numbers use the syntax
       '\d(65)'  // is the character value decimal 65
       '\x(FF)'  // is the character value hex FF

       Example
       my_lit = "*\tline1 = \"\d(65)\d(66)\d(67)\"\n*\tline2 = \'\x(42)\'\x(43)\n*\tline3 = \o(103)\n";
       my_lit represents a string_literal which should produce when formatted :
         
       *    line1 = "ABC" 
       *    line2 = 'B'C
       *    line3 = C

       Characters in single quotes represent a character_set. 
       Characters in double quotes represent a string. 
       A character_set with a single character is equivalent 
       to a string with a single character and is known as a single_character.
       The empty_set can be represented by "" or ''
   */

   state string_literal {

     '"'       [ popfpos, emit String, jump main ]
     "\\\'"    [ append "\'" ]
     "\\\""    [ append "\"" ]
     "\\a"     [ append "\a" ]
     "\\b"     [ append "\b" ]
     "\\f"     [ append "\f" ]
     "\\n"     [ append "\n"]
     "\\r"     [ append "\r"]
     "\\t"     [ append "\t"]
     "\\v"     [ append "\v"]
     .         [ append $ ] // append anything else
   } 

   state main {

       space      =  ' \t'               ;
       exp        =  'eE'                ;
       sign       =  '+-'                ;
       alpha      =  'A'..'Z' | 'a'..'z' ;
       digit      =  '0'..'9'            ;
       alnum      =  alpha | digit       ;
       ident      =  ( alnum & !digit | '_' ) ( alnum | '_' )* ;
       int        =  digit+                                     ;
       exponent   =  exp sign? digit+                           ;
       real       =  digit* '.' digit+ exponent?          |
                     digit+ ( '.' exponent? | exponent )  ;
       ws         = ( space | newl )+       ;

      "/*"      [ jump mlcomment ]  
      "//"      [ jump slcomment ] 
      '"'      [ pushfpos, jump string_literal ] 

      "keyword" [ append $, emit Keyword   ]
      int       [ append $, emit Integer  ]
      real      [ append $, emit Real     ]
      ws        [ /* eat whitespace*/    ]     
      '(' | ')' [ emit $ ]
      ident     [ append $, emit Ident ]
   }

   state mlcomment {
     
      "*/"      [ jump main ] 
      .         [] // eat anything else
   }

   state slcomment {

      newl      [ jump main ]
      .         [ ] //eat anything else
   }
